package com.ibkr.marketstrategy;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Objects;

/**
 * Represents a trading signal generated by a strategy.
 * It includes details such as the stock symbol, the action (BUY/SELL),
 * the price at which the signal was generated, the name of the strategy
 * that generated it, and a reason or context for the signal.
 */
public class TradeSignal {

    /**
     * Defines the possible trading actions.
     */
    public enum Action {
        BUY,  // A signal to enter a long position
        SELL  // A signal to enter a short position or exit a long position
        // HOLD can be represented by the absence of a signal or a specific NoSignal object if needed
    }

    private final String symbol;
    private final Action action;
    private final double price; // Price at which the signal was generated
    private final String strategyName;
    private final String reason; // Additional context or parameters that triggered the signal
    private final LocalDateTime timestamp;

    private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    /**
     * Constructs a new TradeSignal.
     *
     * @param symbol       The stock symbol (e.g., "AAPL").
     * @param action       The trading action (BUY or SELL).
     * @param price        The price at which the signal was generated.
     * @param strategyName The name of the strategy that generated this signal.
     * @param reason       A brief description or data points that led to this signal.
     */
    public TradeSignal(String symbol, Action action, double price, String strategyName, String reason) {
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.action = Objects.requireNonNull(action, "Action cannot be null");
        this.price = price;
        this.strategyName = Objects.requireNonNull(strategyName, "Strategy name cannot be null");
        this.reason = reason; // Reason can be null or empty
        this.timestamp = LocalDateTime.now();
    }

    // Getters
    public String getSymbol() {
        return symbol;
    }

    public Action getAction() {
        return action;
    }

    public double getPrice() {
        return price;
    }

    public String getStrategyName() {
        return strategyName;
    }

    public String getReason() {
        return reason;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    @Override
    public String toString() {
        return String.format("TradeSignal{strategy='%s', symbol='%s', action=%s, price=%.2f, reason='%s', time='%s'}",
                strategyName, symbol, action, price, reason != null ? reason : "N/A", timestamp.format(dtf));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TradeSignal that = (TradeSignal) o;
        return Double.compare(that.price, price) == 0 &&
               Objects.equals(symbol, that.symbol) &&
               action == that.action &&
               Objects.equals(strategyName, that.strategyName) &&
               Objects.equals(reason, that.reason) &&
               Objects.equals(timestamp.withNano(0), that.timestamp.withNano(0)); // Compare with second precision for practical equality
    }

    @Override
    public int hashCode() {
        // Exclude timestamp from hashCode for simpler equality based on core signal data,
        // or include it if timestamp uniqueness is critical for identity.
        // For now, keeping it simple.
        return Objects.hash(symbol, action, price, strategyName, reason, timestamp.withNano(0));
    }
}
